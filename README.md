# MARVEL FRONTEND TEST
## How to start the project locally
### Development
To run the development server, follow these steps:

1. Clone this repository.
2. Navigate to the project directory and run `npm install` to install all required dependencies.
3. After the installation is complete, run `npm run dev` to start the local server.
4. Open any browser and navigate to `http://localhost:5173/`

### Production
To run the production server locally, follow these steps:

1. Clone this repository.
2. Navigate to the project directory and run `npm install` to install all required dependencies.
3. After the installation is complete, run `npm run build`. This command uses `vite build` to minify and prepare the code for production.
4. Run `npm run preview`. It will start the production build locally, allowing you to preview the application in production mode. Please note that you must complete step 3 before running the production build locally or you will run into an error.
5. Open any browser to navigate to `http`

## Differences between starting in production mode or development mode
### Development mode
Running in development mode will provide features like hot module replacement, fast refresh, and unbundled module serving. This server is optimized for quick development iterations (see changes in real time when developing)
### Production mode
Running in production mode will serve the application as it would be in a production environment, using the build output generated by `vite build`. This command does not provide fast refresh or hot module replacement. Instead, it serves the optimized, minified code.

### Testing
In order to run all tests to validate that everything works correctly, you can run the command `npm run test`

### Important
I've intentionally saved .env to this project so that you can test this app without having to create an API key in Marvel.

## Project overview
This is my submission for the Marvel Frontend Test. To demonstrate my ability to implement core functionalities from scratch, I’ve chosen to **avoid using third-party libraries** (with the exception of essential ones like react-router-dom or axios). This approach allows you to evaluate my skills in creating various tools and components.

## Tech Stack
	Vite: Build tool that provides fast and optimized development.
	CSS: Styling language for designing the user interface with CSS variables.
	React: JavaScript library for building user interfaces.
	Vitest: Testing framework for running unit tests.
    React Testing Library: Testing library that works together with Vitest to test React components.
	Context API: State management solution for managing global state in React.
	Prettier: Code formatter to ensure consistent code style.
	ESLint: Linting tool for identifying and fixing code quality issues.

## Functionalities

### Caching
In a real-world project, I would typically use Tanstack Query (also known as React Query) primarily for its powerful caching functionality. However, as previously mentioned, I’ve opted not to use any third-party libraries for this test to demonstrate my ability to implement core features independently.

To avoid unnecessary API calls, I developed a custom caching system for this project. This system saves API responses in session storage, allowing subsequent requests for the same resource to be served from the cache instead of making a new API call. Additionally, I implemented a cache expiration time of 5 minutes. This ensures that after 5 minutes, the cache is invalidated, and the latest information is fetched. While it’s unlikely that Marvel updates its data frequently enough for this to be necessary, it’s a best practice to design cache systems with proper invalidation strategies to ensure data consistency and reliability.

### API Calls
I’ve chosen to use Axios for handling all data fetching due to its robust error handling capabilities. To avoid repetitively writing out the full URL and parameters for each API call, I created an Axios instance with the `baseURL` set to https://gateway.marvel.com/v1/public. Additionally, I’ve configured the necessary parameters within this instance, eliminating the need to specify them for every API request. This approach results in cleaner, more maintainable code.

Example:
```js
const response = await api.get(`/characters/1/comics`, {
    params: {
        orderBy: '-onsaleDate',
        limit: 20,
    },
```

### Offline storage
Given that the test specifies the app should be able to save favorite characters, I’ve opted to use local storage. While I considered using session storage, I ultimately chose local storage because, in a real-world application, it makes more sense for this information to persist even after the browser is closed.

To interact with local storage, I created a custom hook that can be reused for various purposes. This approach not only provides a practical solution but also demonstrates my ability to write versatile custom hooks.

## Images

I decided to use both the public/assets folder and images within the src folder to demonstrate how I handle assets in different scenarios. You’ll notice that all icons, except for Spinner.png, are SVG elements. Initially, I intended to use an SVG for the spinner as well, aiming for a design that fits the theme of the test. I found a Deadpool SVG online, but encountered a console warning due to an unsupported HTML element within the SVG. To resolve this issue, I switched to using the PNG version of the spinner instead.

## Testing
I have written a suite of tests to ensure the robustness and reliability of the code. The suite includes 23 test files, covering a total of 60 test cases. This suite of tests addresses various use cases, providing confidence that the application functions correctly under different conditions.

In order to run all tests to validate that everything works correctly, you can run the command `npm run test`


## npmrc
To ensure that anyone cloning the repository installs the exact versions of dependencies used during development, I created a `.npmrc` file. This file automatically sets the `--save-exact` flag, ensuring that exact versions are saved in package.json. This practice promotes consistency and avoids potential issues caused by version mismatch.

## Extras

 I have implemented all the required features for the test and added some extras to enhance the application’s robustness and user experience:1. I've added a generic 404 page incase someone tries to navigate to a undesired route.

	1.	404 page: I included a generic 404 page to handle navigation to undefined routes.
	2.	Caching: To avoid unnecessary API calls and improve performance, I implemented a caching system.
	3.	Error handling: I added error handling for scenarios where a user tries to find a non-existent character.
	4.	CSS Variables: I utilized CSS variables for better maintainability and consistency in styling.
	5.	Spinner: I added a spinner to indicate loading states.
	6.	Character descriptions: For characters without a description, I provided a default description.

## Project structure
**assets**: This folder contains SVG assets used in the application. These images are used in various components.

**components**: Reusable pieces of the UI, categorized by their functionality (e.g., character, comic, favorite).

**hooks**:  Custom React hooks that encapsulate reusable logic, such as fetching data or interacting with local storage.

**lib**: Contains essential files that are integral to the application’s overall functionality, such as context, API configurations, and caching mechanisms.

**pages**: High-level components representing different routes or views in the application.

**services**: Contains functions that interact with external APIs and handle data fetching.



